
#' Restore a Project
#'
#' Restore a project's dependencies from a lockfile, as previously generated by
#' [snapshot()].
#'
#' @inheritParams renv-params
#'
#' @param lockfile The lockfile to be used for restoration of the associated
#'   project. When `NULL`, the most recently generated lockfile for this project
#'   is used.
#'
#' @param library The library paths to be used during restore. See **Library**
#'   for details.
#'
#' @param clean Boolean; remove packages not recorded in the lockfile from
#'   the target library? Use `clean = TRUE` if you'd like the library state
#'   to exactly reflect the lockfile contents after `restore()`.
#'
#' @section Library:
#'
#' When `renv::restore()` is called, packages from the lockfile are compared
#' against packages currently installed in the library paths specified by
#' `library`. Any packages which have changed will then be installed into the
#' default library. If `clean = TRUE`, then packages that exist within the
#' default library, but aren't recorded in the lockfile, will be removed as
#' well.
#'
#' @family reproducibility
#'
#' @export
#'
#' @example examples/examples-init.R
restore <- function(project  = NULL,
                    ...,
                    library  = NULL,
                    lockfile = NULL,
                    clean    = FALSE,
                    confirm  = interactive())
{
  renv_consent_check()
  renv_scope_error_handler()

  project  <- project %||% renv_project()
  library  <- library %||% renv_libpaths_all()
  lockfile <- lockfile %||% renv_lockfile_load(project = project)

  # activate the requested library
  ensure_directory(library)
  renv_scope_libpaths(library)

  # perform Python actions on exit
  on.exit(renv_python_restore(project), add = TRUE)

  # resolve the lockfile
  if (is.character(lockfile))
    lockfile <- renv_lockfile_read(lockfile)

  # inject overrides (if any)
  lockfile <- renv_lockfile_override(lockfile)

  # get records for R packages currently installed
  current <- snapshot(project = project,
                      library = library,
                      lockfile = NULL,
                      type = "simple")

  # compare lockfile vs. currently-installed packages
  diff <- renv_lockfile_diff_packages(current, lockfile)

  # don't remove packages unless 'clean = TRUE'
  diff <- renv_vector_diff(diff, if (!clean) "remove")

  # only remove packages from the project library
  difflocs <- map_chr(names(diff), function(package) {
    find.package(package, lib.loc = library, quiet = TRUE) %||% ""
  })

  exclude <- diff == "remove" & dirname(difflocs) != library[[1]]
  diff <- diff[!exclude]

  # don't take any actions with ignored packages
  ignored <- settings$ignored.packages(project = project)
  diff <- diff[renv_vector_diff(names(diff), ignored)]

  if (!length(diff)) {
    name <- if (!missing(library)) "library" else "project"
    vwritef("* The %s is already synchronized with the lockfile.", name)
    return(invisible(diff))
  }

  if (!renv_restore_preflight(project, library, diff, current, lockfile, confirm)) {
    message("* Operation aborted.")
    return(FALSE)
  }

  if (confirm || renv_verbose())
    renv_restore_report_actions(diff, current, lockfile)

  if (confirm && !proceed()) {
    message("* Operation aborted.")
    return(invisible(diff))
  }

  # perform the restore
  status <- renv_restore_run_actions(project, diff, current, lockfile)

  invisible(status)
}

renv_restore_run_actions <- function(project, actions, current, lockfile) {

  packages <- names(actions)

  renv_restore_begin(records = renv_records(lockfile), packages = packages)
  on.exit(renv_restore_end(), add = TRUE)

  # first, handle package removals
  removes <- actions[actions == "remove"]
  enumerate(removes, function(package, action) {
    renv_restore_remove(project, package, current)
  })

  # next, handle installs
  installs <- actions[actions != "remove"]
  packages <- names(installs)

  # perform the install
  library <- renv_libpaths_default()
  records <- renv_retrieve(packages)
  status <- renv_install(records, library, project)

  # detect dependency tree repair
  diff <- renv_lockfile_diff_packages(renv_records(lockfile), records)
  diff <- diff[diff != "remove"]
  if (!empty(diff)) {
    renv_pretty_print_records(
      records[names(diff)],
      "The dependency tree was repaired during package installation:",
      "Call `renv::snapshot()` to capture these dependencies in the lockfile."
    )
  }

  # check installed packages and prompt for reload if needed
  renv_install_postamble(names(records))

  # return status
  invisible(status)

}

renv_restore_state <- function() {
  renv_global_get("restore.state")
}

renv_restore_begin <- function(records = NULL,
                               packages = NULL,
                               handler = NULL,
                               rebuild = NULL,
                               recursive = TRUE)
{

  renv_global_set("restore.state", env(

    # the package records used for restore, providing information
    # on the packages to be installed (their version, source, etc)
    records = records,

    # the set of packages to be installed in this restore session;
    # as explicitly requested by the user / front-end API call
    packages = packages,

    # an optional custom error handler
    handler = handler %||% function(package, action) action,

    # packages which should be rebuilt (skipping the cache)
    rebuild = rebuild,

    # should package dependencies be crawled recursively? this is useful if
    # the records list is incomplete and needs to be built as packages are
    # downloaded
    recursive = recursive,

    # packages which we have attempted to retrieve
    retrieved = new.env(parent = emptyenv()),

    # packages which need to be installed
    install = stack(),

    # a collection of the requirements imposed on dependent packages
    # as they are discovered
    requirements = new.env(parent = emptyenv())

  ))

}

renv_restore_end <- function() {
  renv_global_clear("restore.state")
}

# nocov start

renv_restore_report_actions <- function(actions, current, lockfile) {

  if ("install" %in% actions) {
    renv_pretty_print_records(
      renv_records_select(lockfile, actions, "install"),
      "The following package(s) will be installed:"
    )
  }

  if ("remove" %in% actions) {
    renv_pretty_print_records(
      renv_records_select(current, actions, "remove"),
      "The following package(s) will be removed:"
    )
  }

  if ("upgrade" %in% actions) {
    renv_pretty_print_records_pair(
      renv_records_select(current, actions, "upgrade"),
      renv_records_select(lockfile, actions, "upgrade"),
      "The following package(s) will be upgraded:"
    )
  }

  if ("downgrade" %in% actions) {
    renv_pretty_print_records_pair(
      renv_records_select(current, actions, "downgrade"),
      renv_records_select(lockfile, actions, "downgrade"),
      "The following package(s) will be downgraded:"
    )
  }

  if ("crossgrade" %in% actions) {
    renv_pretty_print_records_pair(
      renv_records_select(current, actions, "crossgrade"),
      renv_records_select(lockfile, actions, "crossgrade"),
      "The following package(s) will be installed:"
    )
  }

}

# nocov end

renv_restore_remove <- function(project, package, lockfile) {
  records <- renv_records(lockfile)
  record <- records[[package]]
  vwritef("Removing %s [%s] ...", package, record$Version)
  paths <- renv_paths_library(project = project, package)
  recursive <- renv_file_type(paths) == "directory"
  unlink(paths, recursive = recursive)
  vwritef("\tOK (removed from library)")
  TRUE
}

renv_restore_preflight_unknown_source <- function(actions, lockfile) {

  records <- renv_records(lockfile)
  matching <- records[renv_vector_intersect(names(records), names(actions))]
  unknown <- Filter(
    function(record) record$Source %in% "unknown",
    matching
  )

  if (empty(unknown))
    return(TRUE)

  if (renv_verbose()) {
    renv_pretty_print_records(
      unknown,
      "The following package(s) were installed from an unknown source:",
      "renv will attempt to install the latest version(s) from CRAN instead."
    )
  }

  FALSE

}

renv_restore_preflight_permissions <- function(library) {

  # check for inability to install in requested library
  access <- file.access(library, 7)
  if (access == 0L)
    return(TRUE)

  if (renv_verbose()) {
    renv_pretty_print(
      library,
      "You do not have permissions to read / write into the requested library:",
      "renv may be unable to restore packages."
    )
  }

  FALSE

}

renv_restore_preflight <- function(project, library, actions, current, lockfile, confirm) {

  # check for packages installed from an unknown source
  ok <- all(
    renv_restore_preflight_unknown_source(actions, lockfile),
    renv_restore_preflight_permissions(library[[1]])
  )

  if (!ok && confirm && !proceed())
    return(FALSE)

  TRUE

}

renv_restore_find <- function(record) {

  # skip packages whose installation was explicitly requested
  state <- renv_restore_state()
  if (record$Package %in% state$packages)
    return("")

  # need to restore if it's not yet installed
  library <- renv_global_get("install.library") %||% renv_libpaths_default()
  path <- file.path(library, record$Package)
  if (!file.exists(path))
    return("")

  # attempt to read DESCRIPTION
  current <- catch(as.list(renv_description_read(path)))
  if (inherits(current, "error"))
    return("")

  # check for matching records
  source <- tolower(record$Source)
  if (empty(source))
    return("")

  # check for an up-to-date version from CRAN
  if (identical(source, "cran")) {
    fields <- c("Package", "Version")
    if (identical(record[fields], current[fields]))
      return(path)
  }

  # otherwise, match on remote fields
  fields <- renv_record_names(record, c("Package", "Version"))
  if (identical(record[fields], current[fields]))
    return(path)

  # failed to match; return empty path
  ""

}

renv_restore_rebuild_required <- function(record) {
  state <- renv_restore_state()
  any(c(NA_character_, record$Package) %in% state$rebuild)
}
