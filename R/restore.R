
#' Restore a Virtual Environment
#'
#' Restore a virtual environment from a manifest, as previously generated by
#' [snapshot()].
#'
#' @param manifest The manifest to be used for restoration of the associated
#'   virtual environment. When `NULL`, the most recently-generated manifest
#'   for this project is used.
#'
#' @inheritParams renv-params
#' @export
restore <- function(manifest = NULL, confirm = interactive()) {

  # resolve the manifest
  manifest <- case(
    is.null(manifest)      ~ renv_manifest_load(),
    is.character(manifest) ~ renv_manifest_read(manifest),
    manifest
  )

  # check to see if the virtual environment used to generate
  # this manifest already exists -- if not, create it
  name <- manifest$Environment$Name
  envir <- renv_paths_environment(name)
  if (!file.exists(envir)) {

    # remove state-related entries from the manifest
    blueprint <- manifest
    blueprint$R$Packages <- NULL

    # write the blueprint
    renv_manifest_write(blueprint, file = envir)

  }

  # detect changes in R packages in the manifest
  old <- snapshot(name, file = NULL)
  new <- manifest

  actions <- renv_manifest_diff_packages(old, new)
  if (!length(actions)) {
    messagef("* Virtual environment '%s' is up to date.", name)
    return(invisible(actions))
  }

  if (confirm || renv_verbose())
    renv_restore_report_actions(actions, old, new)

  if (confirm) {
    response <- readline("Do you want to proceed? [Y/n]: ")
    if (response != "y") {
      message("Operation aborted.")
      return(invisible(actions))
    }
  }

  status <- renv_restore_run_actions(actions, old, new)
  invisible(status)
}

renv_restore_run_actions <- function(actions, old, new) {

  renv_restore_begin()
  on.exit(renv_restore_end(), add = TRUE)

  enumerate(actions, function(package, action) {

    if (action %in% c("install", "upgrade", "downgrade", "crossgrade"))
      renv_restore_install(package, new)
    else if (action %in% c("remove"))
      renv_restore_remove(package, old)
    else
      warningf("Unrecognized action '%s' for package '%s'", action, package)
  })

}

renv_restore_install <- function(package, manifest) {
  record <- manifest$R$Packages[[package]]

  delegate <- getOption("renv.restore.delegate")
  if (is.function(delegate)) {
    status <- tryCatch(delegate(record), error = identity)
    if (identical(status, TRUE))
      return(status)
  }

  source <- record[["Source"]]
  switch(source,
    cran         = renv_restore_install_cran(record),
    bioconductor = renv_restore_install_bioconductor(record),
    github       = renv_restore_install_github(record),
    bitbucket    = renv_restore_install_bitbucket(record),
    renv_restore_install_unknown_source(record)
  )
}

renv_restore_install_bioconductor <- function(record) {
  # TODO
}

renv_restore_install_github <- function(record) {

  if (requireNamespace("remotes", quietly = TRUE))
    return(renv_restore_install_github_remotes(record))

  fmt <- "https://%s/repos/%s/%s/tarball/%s"

  url <- with(record, sprintf(fmt, RemoteHost, RemoteUsername, RemoteRepo, RemoteSha))
  path <- renv_paths_cache("source", record$Package, record$RemoteSha)

  renv_restore_install_package(record, url, path, "source")

}

renv_restore_install_github_remotes <- function(record) {

  messagef("Installing %s [%s] ...", record$Package, record$Version)
  status <- catch(
    remotes::install_github(
      repo = file.path(record$RemoteUsername, record$RemoteRepo),
      ref = record$RemoteRef,
      host = record$RemoteHost,
      upgrade = FALSE,
      quiet = TRUE
    )
  )

  if (inherits(status, "error")) {
    message("\tFAILED")
    return(status)
  }

  message("\tOK (installed from GitHub)")
  return(TRUE)

}

renv_restore_install_bitbucket <- function(record) {
  # TODO
}

renv_restore_install_cran <- function(record) {

  methods <- c(
    renv_restore_install_cran_binary,
    renv_restore_install_cran_source,
    renv_restore_install_cran_archive
  )

  for (method in methods) {
    status <- method(record)
    if (inherits(status, "error"))
      stop(status)

    if (identical(status, TRUE))
      return(TRUE)
  }

  stopf("Failed to restore package '%s' from CRAN", record$Package)

}

renv_restore_install_cran_binary <- function(record) {

  sysname <- Sys.info()[["sysname"]]
  suffix <- switch(sysname, Darwin = "tgz", Windows = "zip", "tar.gz")
  name <- sprintf("%s_%s.%s", record$Package, record$Version, suffix)
  renv_restore_install_cran_impl(record, "binary", name)

}

renv_restore_install_cran_source <- function(record) {

  name <- sprintf("%s_%s.tar.gz", record$Package, record$Version)
  renv_restore_install_cran_impl(record, "source", name)

}

renv_restore_install_cran_archive <- function(record) {

  name <- sprintf("%s_%s.tar.gz", record$Package, record$Version)
  for (repo in getOption("repos")) {
    repo <- file.path(repo, "src/contrib/Archive")
    if (renv_restore_install_cran_impl(record, "source", name, repo))
      return(TRUE)
  }

  return(FALSE)

}

renv_restore_install_cran_impl <- function(record, type, name, repo = NULL) {

  entry <- renv_restore_install_cran_entry(record, type, repo)
  if (empty(entry))
    return(FALSE)

  # TODO: allow version mismatches? (e.g. restore latest instead of requested)
  if (entry$Version != record$Version)
    return(FALSE)

  url <- file.path(entry$Repository, name)
  path <- renv_paths_cache("source", record$Package, name)

  renv_restore_install_package(record, url, path, type)

}


renv_restore_install_cran_entry <- function(record, type, repo) {

  if (!is.null(repo))
    return(c(record, Repository = repo))

  db <- available_packages(type = type)
  if (!record$Package %in% rownames(db))
    return(list())

  db[record$Package, ]

}

renv_restore_install_package <- function(record, url, path, type) {

  # download the package
  # TODO: toggle path based on whether package cache is enabled?
  if (!file.exists(path)) {
    ensure_parent_directory(path)
    status <- catch(download(url, destfile = path))
    if (inherits(status, "error") || identical(status, FALSE))
      return(status)
  }

  # install package from local copy
  messagef("Installing %s [%s] ...", record$Package, record$Version)
  status <- tryCatch(
    renv_restore_install_package_local(record$Package, path, type = type),
    condition = identity
  )

  # check for success / failure
  if (inherits(status, "condition")) {
    message("\tFAILED")
    return(status)
  }

  # notify user of status
  feedback <- case(

    !is.null(record$RemoteType)
      ~ paste("installed from", renv_alias(record$RemoteType)),

    type == "source" ~ "built from source",
    type == "binary" ~ "installed binary"
  )

  message(feedback)
  TRUE

}

renv_restore_install_package_local <- function(package, path, type) {

  # get user-defined options to apply during installation
  options <- renv_restore_install_package_options(package)

  # run user-defined hooks before, after install
  before <- options$before.install %||% identity
  after  <- options$after.install %||% identity

  before(package)
  on.exit(after(package), add = TRUE)

  utils::install.packages(

    pkgs = path,
    repos = NULL,
    type = type,
    quiet = TRUE,

    configure.args = options$configure.args,
    configure.vars = options$configure.vars,
    INSTALL_opts   = options$install.options

  )

}

renv_restore_remove <- function(package, manifest) {
  entry <- manifest$R$Packages[[package]]
  messagef("Removing %s [%s] ...", package, entry$Version)
  remove.packages(package, renv_paths_library(entry$Library))
  message("\tOK (removed from library)")
  TRUE
}

renv_restore_begin <- function() {

}

renv_restore_end <- function() {

}

renv_restore_report_actions <- function(actions, old, new) {

  if ("install" %in% actions) {
    msg <- "The following package(s) will be installed:"
    renv_pretty_print(msg, new, actions, "install")
  }

  if ("remove" %in% actions) {
    msg <- "The following package(s) will be removed:"
    renv_pretty_print(msg, old, actions, "remove")
  }

  if ("upgrade" %in% actions) {
    msg <- "The following package(s) will be upgraded:"
    renv_pretty_print_pair(msg, old, new, actions, "upgrade")
  }

  if ("downgrade" %in% actions) {
    msg <- "The following package(s) will be downgraded:"
    renv_pretty_print_pair(msg, old, new, actions, "downgrade")
  }

  if ("crossgrade" %in% actions) {
    msg <- "The following package(s) will be modified:"
    renv_pretty_print_pair(msg, old, new, actions, "crossgrade")
  }

}

renv_restore_install_package_options <- function(package) {
  options <- getOption("renv.install.package.options")
  options[[package]]
}

renv_restore_install_unknown_source <- function(record) {
  fmt <- "Can't restore package '%s': '%s' is an unrecognized source."
  stopf(fmt, record$Package, record$Source, call. = FALSE)
}
