
#' Restore a Virtual Environment
#'
#' Restore a virtual environment from a manifest, as generated by
#' [renv_snapshot()].
#'
#' @param manifest The manifest to be used for restoration of the associated
#'   virtual environment.
#'
#' @inheritParams renv-params
#' @export
renv_restore <- function(manifest = NULL, confirm = interactive()) {

  manifest <- case(
    is.null(manifest)      ~ renv_manifest_load(),
    is.character(manifest) ~ renv_manifest_read(manifest),
    manifest
  )

  name <- manifest$Environment$Name

  old <- renv_snapshot(name, file = NULL)
  new <- manifest

  actions <- renv_manifest_diff_packages(old, new)
  if (!length(actions)) {
    messagef("* Virtual environment '%s' is up to date.", name)
    return(invisible(actions))
  }

  if (confirm || renv_verbose())
    renv_restore_report_actions(actions, old, new)

  if (confirm) {
    response <- readline("Do you want to proceed? [Y/n]: ")
    if (response != "y") {
      message("Operation aborted.")
      return(invisible(actions))
    }
  }

  status <- renv_restore_run_actions(actions, old, new)
  invisible(status)
}

renv_restore_run_actions <- function(actions, old, new) {

  renv_restore_begin()
  on.exit(renv_restore_end(), add = TRUE)

  enumerate(actions, function(package, action) {

    if (action %in% c("install", "upgrade", "downgrade", "crossgrade"))
      renv_restore_install(package, new)
    else if (action %in% c("remove"))
      renv_restore_remove(package, old)
    else
      warningf("Unrecognized action '%s' for package '%s'", action, package)
  })

}

renv_restore_install <- function(package, manifest) {
  record <- manifest$R$Packages[[package]]

  delegate <- getOption("renv.restore.delegate")
  if (is.function(delegate)) {
    status <- tryCatch(delegate(record), error = identity)
    if (identical(status, TRUE))
      return(status)
  }

  source <- record[["Source"]]
  switch(source,
    Bioconductor = renv_restore_install_bioconductor(record),
    GitHub       = renv_restore_install_github(record),
    BitBucket    = renv_restore_install_bitbucket(record),
    renv_restore_install_cran(record)
  )
}

renv_restore_install_bioconductor <- function(record) {
  # TODO
}

renv_restore_install_github <- function(record) {
  # TODO
}

renv_restore_install_bitbucket <- function(record) {
  # TODO
}

renv_restore_install_cran <- function(record) {

  methods <- c(
    renv_restore_install_cran_binary,
    renv_restore_install_cran_source,
    renv_restore_install_cran_archive
  )

  for (method in methods) {
    status <- method(record)
    if (inherits(status, "error"))
      stop(status)

    if (identical(status, TRUE))
      return(TRUE)
  }

  stopf("Failed to restore package '%s' from CRAN", record$Package)

}

renv_restore_install_cran_binary <- function(record) {

  sysname <- Sys.info()[["sysname"]]
  suffix <- switch(sysname, Darwin = "tgz", Windows = "zip", "tar.gz")
  name <- sprintf("%s_%s.%s", record$Package, record$Version, suffix)
  renv_restore_install_cran_impl(record, "binary", name)

}

renv_restore_install_cran_source <- function(record) {

  name <- sprintf("%s_%s.tar.gz", record$Package, record$Version)
  renv_restore_install_cran_impl(record, "source", name)

}

renv_restore_install_cran_archive <- function(record) {

  name <- sprintf("%s_%s.tar.gz", record$Package, record$Version)
  for (repo in getOption("repos")) {
    repo <- file.path(repo, "src/contrib/Archive")
    if (renv_restore_install_cran_impl(record, "source", name, repo))
      return(TRUE)
  }

  return(FALSE)

}

renv_restore_install_cran_impl <- function(record, type, name, repo = NULL) {

  entry <- renv_restore_install_cran_entry(record, type, repo)
  if (empty(entry))
    return(FALSE)

  # TODO: allow version mismatches?
  if (entry$Version != record$Version)
    return(FALSE)

  # TODO: how to evict from cache if needed?
  cache <- renv_paths_cache(type, record$Package, name)
  if (!file.exists(cache)) {
    url <- file.path(entry$Repository, name)
    ensure_parent_directory(cache)
    status <- tryCatch(download(url, destfile = cache), error = identity)
    if (inherits(status, "error") || identical(status, FALSE))
      return(status)
  }

  # TODO: validate installed dependencies?
  messagef("Installing %s (%s) ...", record$Package, record$Version)
  status <- tryCatch(
    install.packages(cache, repos = NULL, type = type, quiet = TRUE),
    condition = identity
  )

  if (inherits(status, "condition")) {
    message("\tFAILED")
    return(status)
  }

  msg <- case(
    type == "binary" ~ "\tOK (installed binary)",
    type == "source" ~ "\tOK (built from source)"
  )

  message(msg)
  TRUE

}

renv_restore_install_cran_entry <- function(record, type, repo) {

  if (!is.null(repo))
    return(c(record, Repository = repo))

  db <- available_packages(type = type)
  if (!record$Package %in% rownames(db))
    return(list())

  db[record$Package, ]

}

renv_restore_remove <- function(package, manifest) {
  entry <- manifest$R$Packages[[package]]
  messagef("Removing %s (%s) ...", package, entry$Version)
  remove.packages(package, renv_paths_library(entry$Library))
  message("\tOK (removed from library)")
  TRUE
}

renv_restore_begin <- function() {

}

renv_restore_end <- function() {

}

renv_restore_report_actions <- function(actions, old, new) {

  if ("install" %in% actions) {
    msg <- "The following package(s) will be installed:"
    renv_pretty_print(msg, new, actions, "install")
  }

  if ("remove" %in% actions) {
    msg <- "The following package(s) will be removed:"
    renv_pretty_print(msg, old, actions, "remove")
  }

  if ("upgrade" %in% actions) {
    msg <- "The following package(s) will be upgraded:"
    renv_pretty_print_pair(msg, old, new, actions, "upgrade")
  }

  if ("downgrade" %in% actions) {
    msg <- "The following package(s) will be downgraded:"
    renv_pretty_print_pair(msg, old, new, actions, "downgrade")
  }

  if ("crossgrade" %in% actions) {
    msg <- "The following package(s) will be modified:"
    renv_pretty_print_pair(msg, old, new, actions, "crossgrade")
  }

}
